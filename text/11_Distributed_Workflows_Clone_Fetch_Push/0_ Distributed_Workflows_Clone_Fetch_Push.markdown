## Распределенный рабочий процесс ##

Предположим что Алиса начала новый проект с git репозиторием в директории /home/alice/project, и что Боб, у которого есть своя домашняя директории на той же машине, хочеть помочь с проектом.

Боб начнет работу с:

    $ git clone /home/alice/project myrepo

Это создаст новую директорию "myrepo" содержащую копию репозитория Алисы.
Клон эквивалентен в основании оригиналу проекта, и обладает своей копией истории оригинального проекта.

Затем Боб вносит некоторые изменения и выполняет коммит:


    (edit files)
    $ git commit -a
    (repeat as necessary)

Когда он готов, он сообщает Алисе вытянуть изменения из репозитория в  /home/bob/myrepo.  Она совершает это выполнив:

    $ cd /home/alice/project
    $ git pull /home/bob/myrepo master

Это сливает изменения из ветки "master" Боба в активную ветку Алисы. Если Алиса внесла изменения в свою ветку в тоже самое время, тогда возможно ей придется вручную исправить конфликты если таковые появятся. (Заметьте аргумент "master" в команде выше в действительности не требуется, так как он будет использоваться по умолчанию.)

Команда "pull" таким образом выполняет два действия: она вытягивает изменения из удаленного репозитория, и сливает их в активную ветку.

Когда вы работаете в маленькой группе разработчиков, это обыкновенная практика работать с одим и тем же репозиторием снова и снова. Определив сокращение 'remore' репозитория вы можете упростить себе работу:

    $ git remote add bob /home/bob/myrepo

С этим Алиса, может выполнять первую операцию одной командой "git fetch" без сливания их в свою ветку:

    $ git fetch bob

В отличие от полной формы, когда Алиса вытягивает изменения из 'remote' репозитория Боба используя сокращение с помощью `git remote`, то что было вытянуто хранится в удаленной отслеживающей ветке, в нашем случае это
`bob/master`.  Так после этого:

    $ git log -p master..bob/master

покажет список всех изменений которые Боб сделал с того времени как он ответвился от ветки "master" Алисы.

После проверки этих изменений, Алиса может слить изменения в свою ветку master:

    $ git merge bob/master

Этот `merge` может также быть выполнено с помощью 'вытягивания из ее собственной удаленной отслеживаемой ветки', слею.образом:

    $ git pull . remotes/bob/master

Заметьте что команда git pull всегда сливает в активную ветку, не обращая внимания на другие аргументы в командной строке.

Позже Боб, может обновить свой репозиторий включив последние обновления Алисы, выполнив

    $ git pull

Заметьте что ему не требуется указывать путь к репозиторию Алисы; когда Боб клонирует репозиторий Алисы, git хранит местоположение ее репозитория в настройках репозитория, и это расположние используется для извлечения:

    $ git config --get remote.origin.url
    /home/alice/project

(Полные настойки созданы командой git-clone. Их можно просмотреть с помощью "git config -l", страница справочника linkgit:git-config[1] описывает значения каждого параметра.)

Git также держит чистую копию ветки "master" Алисы под именем "origin/master":

    $ git branch -r
      origin/master

Ecли Боб позже решит работать с другой машины, он все еще может выполнить клонирование и вытянуть данные используя ssh протокол:

    $ git clone alice.org:/home/alice/project myrepo

Кроме того, у git есть свой родной протокол, или можно использовать rsync или http; просмотрите linkgit:git-pull[1] чтобы получить больше подробностей.

Git может также быть использован в режиме CVS, центрального репозитория в который различные пользователи добавляют изменения; просмотрите linkgit:git-push[1] и linkgit:gitcvs-migration[1].


### Открытые git репозитории ###

Другой путь передать изменения в проект это попросить мантейнера проекта вытянуть изменения из вашего репозитория используя linkgit:git-pull[1]. Это способ получить обновления из "main" репозитория, но он работает также хорошо в другом направлении..

Если вы и мантейнер оба имеет учетную запись на одной машине, тогда вы можете просто вытянуть изменения друг от друга репозириев напрямую; команды которые допускают URLы репозиторией как аргумент также допускают имя локальной директории:

    $ git clone /path/to/repository
    $ git pull /path/to/other/repository

или ssh URL:

    $ git clone ssh://yourhost/~you/repository

Для проектов с малым количеством разработчиков, или для синхронизации нескольких частных репозиториев, это именно то что вам нужно.

Как бы так ни было, более общий способ сделать это открыть отдельный общественный репозиторий (обычно на отдельной машине) для других из которого они могли вытягивать изменения. Обычно это более удобный способ, и позволяет вам очистить отдельную частную работу от отщественной видимой работы.

Вы продолжите делать вашу повседневную работу в вашем личном репозитории, но периодически будете вытягивать изменения из вашего личного репозитория в ваш общественный репозиторий, позволяя другим разработчикам вытигивать из этого репозитория. Так поток изменений, в ситуации где есть один разработчик с общественным репозиторием, выглядит так:

                            you push
      your personal repo ------------------> your public repo
    	^                                     |
    	|                                     |
    	| you pull                            | they pull
    	|                                     |
    	|                                     |
            |               they push             V
      their public repo <------------------- their repo
      


### Внесение изменений в общественный репозиторий ###

Заметьте что экспорт через http или git позволяет другим мантейнерам получать ваши изменения, но у них нет доступа на запись. Для этого вам нужно обновить общественный репозиторий и включить туда последние обновления созданные в вашем частном репозитории.

Простейший способ сделать это - использовать linkgit:git-push[1] и ssh; чтобы обновить удаленную ветку по имени "master" с последним состоянием вашей ветки под именем "master", выполните

    $ git push ssh://yourserver.com/~you/proj.git master:master

или просто

    $ git push ssh://yourserver.com/~you/proj.git master

Как и git-fetch, git-push будет жаловаться если это не результат fast forward; просмотрите след.секцию для подробностей как решить эту проблему.

Заметьте что цель "push" обычно пустой репозиторий. Вы также можете выполнить push в репозиторий который имеет извлеченное рабочее дерево, но рабочее дерево не обновится выполнением push. Этот способ ведет к неопределенным результатам если ветка в которую вы выполняете push активная извлеченная ветка!

Также как и с git-fetch, вы возможно также установите параметры конфигурации для безопасной печати; так например после

    $ cat >>.git/config <<EOF
    [remote "public-repo"]
    	url = ssh://yourserver.com/~you/proj.git
    EOF

вы должны быть способны выполнить push выше след.образом

    $ git push public-repo master

Просмотрите объяснение remote.<name>.url, branch.<name>.remote,
and remote.<name>.push параметры в linkgit:git-config[1] для получения подробностей.

### Что делать если выполнение push провалилось ###

Если выполнение push не закончится fast forward удаленной ветки, то ошибка будет выглядеть как:

    error: remote 'refs/heads/master' is not an ancestor of
    local  'refs/heads/master'.
    Maybe you are not up-to-date and need to pull first?
    error: failed to push to 'ssh://yourserver.com/~you/proj.git'

Это может случиться, например если вы:

	- использовали `git-reset --hard` чтобы удалить уже опубликованные коммиты или
	- использовали `git-commit --amend` чтобы заменить уже опубликованные коммиты или
	- использовали `git-rebase` чтобы переопределить любой уже опубликованный коммиты.

Вы также можете заставить git-push выполнить обновление в любом случае если перед именем ветки поставите символ плюс:

    $ git push ssh://yourserver.com/~you/proj.git +master

Обычно всякий раз когда голова ветки в общественном репозитории модифицируется, оно модифицируется так чтобы указывать на потомка коммита на который оно указывало до этого. Принуждая выполнение push в такой ситуации, вы нарушаете это соглашение.

Тем не мене, это общая практика для людей которым нужен простой способ опубликовать серию патчей работа в прогрессе, и это допустимый компромис пока другие разработчики предупреждены каким образом вы намереваетесь управлять веткой.

Это также возможно что выполнение push ну удастся этим способом когда другие разработчики имеют права на выполнение push  в тот же репозиторий. В этом случае правильное решение это повторить push после первого обновления вашей работы или выполнив pull или выполнив fetch с последующим rebase.; Просмотрите след. секцию и linkgit:gitcvs-migration[7] для больших деталей.

[gitcast:c8-dist-workflow]("GitCast #8: Distributed Workflow")


Примечание
The clone is on an equal footing with the original
project, possessing its own copy of the original project's history.
Перевод этого предложения не думаю что правильный