## Управление ветвлением и слиянием ##

Один git репозиторий может заключать в себе множество ветвей разработки. Чтобы создать новое ответвление под именем "experimental", выполните команду

    $ git branch experimental

Теперь если вы выполните

    $ git branch

то получите список всех существующих ветвей:

      experimental
    * master

Ветка "experimental" это та, которую вы только что создали, а ветка "master" это ветка по умолчанию которая создается автоматически. Звездочка указывает в какой ветке вы в данный момент находитесь; наберите

    $ git checkout experimental

чтобы переключиться в ветку experimental. Теперь отредактируйте файл, выполните комит, и переключитесь обратно в главную ветку "master":

    (edit file)
    $ git commit -a
    $ git checkout master

Убедитесь, что сделанные изменения невидимы, поскольку они были сделаны в ветке experimental, а вы сейчас в главной ветке "master".

Вы можете сделать другое изменение в ветке "master", затем выполнить коммит:

    (edit file)
    $ git commit -a

на этом этапе две ветки разошлись, поскольку в каждой из них различные изменения. Чтобы включить изменения в ветке experimental в master, выполните

    $ git merge experimental

Если изменения не конфликтуют, то вы закончили. Если же существуют какие либо конфликты, то в проблемных файлах останутся заметки которые можно увидеть выполнив;

    $ git diff

Как только вы отредактировали файлы вызывающие конфликты выполните,

    $ git commit -a

это выполнит коммит результат слияния. В заключении,

    $ gitk

покажет наглядное графическое представление истории.

Теперь вы можете удалить ветку experimental командой

    $ git branch -d experimental

Эта команда гарантирует что изменения в ветке experimental уже в текущей активной ветке.(Прим. переводчика: если вы попытаетесь удалить ветку которую вы не слили со своей рабочей git выведет предупреждение и попросит вас выполнить след.команду $ git branch -D experimental)

Если вы отрабатываете в ветке сумашедшие идеи, и уже пожалели об этой ветке, вы всегла можете удалить ветку выполнив

    $ git branch -D crazy-idea

Ветки это легко и просто, и это хороший способ попробовать что то новое.

### Как сливать ветки ###

Вы можете объединить две разошедшиеся ветки разработки используя
linkgit:git-merge[1]:

    $ git merge branchname

сливает изменения сделанные в ветке "branchname" в активную(рабочую) ветку.  Если присутствуют конфликты -- например один и тот же файл модифицирован разными способами в удаленной и локальной ветках -- то вы будете предупреждены; вывод будет выглядеть след. образом:

    $ git merge next
     100% (4/4) done
    Auto-merged file.txt
    CONFLICT (content): Merge conflict in file.txt
    Automatic merge failed; fix conflicts and then commit the result.

Отметки конфликтов останутся в проблемных файлах, и после того как вы исправите их вручную, вы можете обновить индекс и выполнить git commit, как вы обычно это делаете когда изменяете файл.

Если вы просмотрите результирующий коммит используя gitk, вы увидите что у него два родителя: один указывает на последний коммит активной ветки, а другой на последний коммит другой ветки.

### Исправление конфликтов при слиянии ###

Когда слияние не происходит автоматически, git оставляет индекс и рабочее дерево в особом состоянии которое дает всю информацию необходимую чтобы разрешить конфликт.

Файлы с конфликтами отмечаются в индексе особым образом, так что до тех пор пока вы не исправите проблему и не обновите индекс, выполненить linkgit:git-commit[1] не удастся:

    $ git commit
    file.txt: needs merge

Также, linkgit:git-status[1] перечислит эти файлы как "unmerged", а файлы с конфликтами будут иметь добавленные отметки, и выглядеть след.образом:

    <<<<<<< HEAD:file.txt
    Hello world
    =======
    Goodbye
    >>>>>>> 77976da35a11db4580b80ae27e8d65caf5208086:file.txt

Все что вам нужно это отредактировать файлы чтобы исправить конфликты, а затем выполнить

    $ git add file.txt
    $ git commit

Заметьте что сообщение-описание коммита уже будет содержить некоторую информацию о слиянии. Обычно вы можете оставить это сообщение-описпние неизмененным, но вы можете добавить свои дополнительные комментарии, если пожелаете.

Теперь вы знаете все что вам нужно чтобы выполнить простое слияние. Но git  предостваляет больше информации, чтобы помочь разрешить конфликты:

### Отменить слияние ###

Если в процессе слияния и исправления конфликтов,вы застряли и решили сдаться и выбросить все к черту, то вы всегда можете вернуться с состоянию pre-merge (такое же как и было до того как вы запустили слияние) выполнив

    $ git reset --hard HEAD

Если вы уже выполнили коммит после слияния, и вы хотите сбросить это,

    $ git reset --hard ORIG_HEAD

Как бы там ни было, последняя команда может быть опасной в некоторых случаях --никогда не сбрасывайте коммит если этот коммит возможно уже был использован в слиянии в другую ветку, если вы это сделаете то это запутает последующие слияния.

### fast-forwarding слияния ###

Есть один специальный случай не упомянутый выше, который несколько иной по сути. Обычно, результаты слияния это коммит слияния у которого два родителя, один на каждую ветку разработки.

Однако в некоторых случаях когда активная ветка не отклонилась от другой -- и  каждый коммит в активной ветке уже содержится в другой -- то git просто выполняет "fast forward"; голова активной ветки перемещается вперед и указвается на голову сливаемой ветки, без создания каких-либо новых коммитов.

[gitcast:c6-branch-merge]("GitCast #6: Branching and Merging")

