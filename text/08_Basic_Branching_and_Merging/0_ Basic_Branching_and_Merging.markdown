## Управление ветвлением и слиянием ##

Один git репозиторий может заключать в себе множество ветвей разработки. Чтобы создать новое ответвление с именем "experimental", выполните команду

    $ git branch experimental

Теперь если вы выполните

    $ git branch

то получите список всех существующих ветвей:

      experimental
    * master

Ветка "experimental" это та что вы только что создали а ветка "master" это ветка по умолчанию которая создается автоматически. Звездочка указывает в какой ветке вы в данный момент;
наберите

    $ git checkout experimental

чтобы переключиться в ветку experimental. Теперь отредактируйте файл, выполните комит, и переключитесь обратно в главную ветку "master":

    (edit file)
    $ git commit -a
    $ git checkout master

Убедитесь что сделанные изменения невидимы, поскольку они были сделаны в ветке experimental а вы сейчас в главной ветке "master".

Вы можете сделать разные изменения в ветке "master", затем закоммить их:

    (edit file)
    $ git commit -a

на этом этапе две ветки разошлись, поскольку в каждой из них различные изменения. Чтобы включить изменения в ветке experimental в master, выполните

    $ git merge experimental

Если изменения не конфликтуют, то вы закончили. Если же существуют какие либо конфликты, то проблемных файлах останутся заметки которые можно увидеть выполнив;

    $ git diff

Как только вы отредактировали файлы вызывающие конфликты выполните,

    $ git commit -a

это выполнит коммит результат слияния. В заключении,

    $ gitk

покажет нагладное графическое представление истории.

Теперь вы можете удалить ветку experimental командой

    $ git branch -d experimental

Эта команда гарантирует что изменения в ветке experimental уже в текущей активной ветке.

Если вы отрабатываете в ветке сумашедшие идеи, и уже пожалели об этой ветке, вы всегла можете удалить ветку выполнив

    $ git branch -D crazy-idea

Ветки это легко и просто, и это хороший способ попробовать что то новое.

### Как сливать ветки ###

Вы можете объединить две разошедшиеся ветки разработки используя
linkgit:git-merge[1]:

    $ git merge branchname

сливает изменения сделанные в ветке "branchname" в активную(рабочую) ветку.  Если присутствуют конфликты -- например один и тот же файл модифицирован разными способами в удаленной и локальной веткях -- то вы будете предупреждены; вывод будет выглядеть как то так:

    $ git merge next
     100% (4/4) done
    Auto-merged file.txt
    CONFLICT (content): Merge conflict in file.txt
    Automatic merge failed; fix conflicts and then commit the result.

Заметки конфликтов останутся в проблемных файлах, и после того как вы исправите их вручную, вы можете перенести в содержимое директории заморозки и выполнить git commit, как вы обычно это делаете когда изменяете файл.

Если вы исследуете результирующий коммит используя gitk, вы увидите что у него два родителя: один указывает на верх активной ветки, а другой на верх другой ветки.

### Исправление слияния ###

Когда слияние не происходит автоматически, git оставляет директорию заморозки и рабочее дерево в особом состоянии которое дает вам всю информацию необходимую чтобы разрешить конфликт.

Файлы с конфликтами отмечаются в директории заморозки особым образом, так что до тех пор пока вы не исправите проблему и не обновите директорию заморозки, команда linkgit:git-commit[1] не будет работать:

    $ git commit
    file.txt: needs merge

Также, linkgit:git-status[1] перечислит те файлы как "unmerged", и файлы с конфликтами будут выглядеть след.образом:

    <<<<<<< HEAD:file.txt
    Hello world
    =======
    Goodbye
    >>>>>>> 77976da35a11db4580b80ae27e8d65caf5208086:file.txt

Все что вам нужно это отредактировать файлы чтобы исправить конфликты, а затем выполнить

    $ git add file.txt
    $ git commit

Заметьте что сообщение-описание коммита уже будет содержить некоторую информацию о слиянии. Обычно вы можете оставить это сообщение-описпние неизмененным, но вы можете добавить свои дополнительные комментарии, если пожелаете.

Теперь вы знаете все что вам нужно чтобы выполнить простое слияние. Но git также обеспечивает больше информации чтобы исправлять конфликты:

### Отменить слияние ###

Если в процессе слияния и исправления конфликтов,вы застряли и решили сдаться и выбросить все к черту, то вы всегда можете вернуться с состоянию pre-merge (такое же как и было до того как вы запустили слияние) выполнив

    $ git reset --hard HEAD

Если вы уже выполнили коммит после слияния, и вы хотите сбросить это,

    $ git reset --hard ORIG_HEAD

Как бы там ни было, последняя команда может быть опасной в некоторых случаях --никогда не сбрасывайте коммит если этот коммит возможно использован в слиянии в другую ветку, если вы это сделаете то это запутает последующие слияния.

### Fast-forward merges ###

Есть один специальный случай не упомянутый выше, с которым обходится следует по другому. Обычно, результаты слияния идут впоследствии в коммит у которого два родителя, один на каждую ветку разработки.

Как бы там ни был если активная ветка не отклонилась от другой -- так что каждый коммит в представленной активной ветке уже содержится в другой -- тогда git просто выполняет "fast forward"; верхушка активной ветки перемещается вреред на место верхушки сливаемой ветки, без создания каких-либо новых коммитов.

[gitcast:c6-branch-merge]("GitCast #6: Branching and Merging")
